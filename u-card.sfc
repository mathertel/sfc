<!--
# Web component to display a card

Creating a complex structure of HTML elements is often required to create the layout and design. This is a typical problem often
solved by using server side rendered components from a template. However this also can be done on the client side - and that is
what is demonstrated here with the `<c-card>` component.

In situations where size matters this may be helpful because the client side created html will need less memory
on the download because of re-use of the template.

## Template processing

This component annotates `<template light>` with the `light` attribute resulting in adding the template code to the inner HTML
of the main document known as light dom instead of the shadow dom.

When the component is then initialized all the inner parts of the `<c-card>` is moved into the slots:

  * The title attribute is used as textContent of the .header>h3
  * The icon attribute is used to create a image as first element in the .header
  * All buttons are moved to the **.footer>slot**
  * All remaining elements are move to the .main>slot
  * empty slots are removed.

This results in simplified HTML for rendering cards:

``` html
???
```

-->

<template light>
  <div class="header">
    <img src="/test/bulb.svg" alt="icon" class="icon" style="display:none"/>
    <svg class="icon">
      <use href="./icons.svg#select"></use>
    </svg>
    <h3></h3>
  </div>
  <div class="main">
    <slot></slot>
  </div>
  <div class="footer">
    <slot></slot>
  </div>
</template>

<style>
  u-card {
    outline: 3px solid lime;
  }
</style>

<script>
  export default class UCard extends UComponent {
    static observedAttributes = ["title", "icon"];
    value = 'black';
    cssvar = '';

    constructor(p) {
      super();
      // UComponent has at this stage already copied the template to the shadow root 

      // move all nodes not from the template into right slot
      const childNodes = Array.from(this.childNodes);
      for (const n of childNodes) {
        if (n.nodeType === Node.TEXT_NODE && n.nodeValue.trim() === '') {
          n.remove(); // remove empty text nodes
        } else {
          if (n.classList?.contains('header')) break;
          // header is first element of template -> stop the loop
          const sl = this.querySelector((n.tagName === 'BUTTON') ? '.footer>slot' : '.main>slot');
          sl.appendChild(n);
        }
      }
    }

    onclick(evt) {
      console.debug("click", evt);
    }

    onchange(evt) {
      console.debug("change", evt);
    }

    init() {
      console.debug('init()');
      document.querySelector('u-card').classList.add('card');
      this.classList.add('card');
    } // init()

    attributeChangedCallback(name, oldValue, newValue) {
      console.debug("attributeChanged", name, oldValue, newValue);

      if (name === 'title') {
        this.querySelector('.header>h3').textContent = newValue;
        // } else if (name === 'icon') {
        //   this.querySelector('.header>h3').textContent = newValue;
      }
    } // attributeChangedCallback()

    adoptedCallback() {
      console.debug("adopted", evt);
    }
  }
</script>