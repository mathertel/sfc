<!--
File: u-splitter.sfc

Copyright (c) 2025 by Matthias Hertel, http://www.mathertel.de
This work is licensed under a BSD-3-Clause license. See http://www.mathertel.de/License.aspx

Implementation of a custom element that enables horizontal or vertical sizing of a pair of regions inside this containter
element.

Example: <u-splitter vertical? > <div>...</div> <div>...</div> </u-splitter>
-->

<template light>
</template>

<style>
  u-splitter {
    position: relative;
    display:block;
    width: 100%;
    height: 100%;
    display: flex;

    .resizer {
      position: absolute;
      background-color: rgba(0, 0, 0, 8%);
      padding: 0;
      margin: 0;
      width: 8px;
      height: 8px;

      &:hover {
        background-color: grey;
      }
    }

    &:not([vertical]) {
      flex-direction: row;

      >.resizer {
        cursor: ew-resize;
        height: 100%;
      }
    }

    &[vertical] {
      flex-direction: column;

      >.resizer {
        cursor: ns-resize;
        width: 100%;
      }
    }
  }
</style>

<script>
  export default class uSplitter extends UComponent {

    // reference to the created bar element    
    #barObj = undefined;

    // reference to the 2 nested panels
    #panelObjs;

    // effective width of the bar from css definition
    #barSize2;

    // this is horizontal splitter case
    #isHorizontal;

    // effective offset for sizing 
    #offset = 0;

    // onmove handler reference that can be canceled
    #fMove;

    // onup handler reference that can be canceled
    #fCancel;

    constructor(p) {
      super();

      this.#panelObjs = this.querySelectorAll(':scope > *');
      if (this.#panelObjs.length != 2) {
        console.error('resizer container must have exact 2 nested elements');

      } else {
        let total, size1, size2;
        const o1 = this.#panelObjs[0];
        const o2 = this.#panelObjs[1];
        const h = this.#isHorizontal = (this.getAttribute('vertical') == undefined);

        this.#barObj = document.createElement('div');
        this.#barObj.className = 'resizer';
        this.appendChild(this.#barObj);

        if (h) {
          this.#barSize2 = Math.floor(this.#barObj.offsetWidth / 2);
          total = this.clientWidth;
          size1 = o1.offsetWidth;
          size2 = o2.offsetWidth;

        } else {
          this.#barSize2 = Math.floor(this.#barObj.offsetHeight / 2);
          total = this.clientHeight;
          size1 = o1.offsetHeight;
          size2 = o2.offsetHeight
        }

        if (total !== size1 + size2) {
          // resize and keep the ratio
          size1 = Math.round((total * size1) / (size1 + size2));
        }

        if (h) {
          o1.style.width = size1 + 'px';
          o2.style.width = (total - size1) + 'px';
          this.#barObj.style.left = (size1 - this.#barSize2) + 'px';

        } else {
          o1.style.height = size1 + 'px';
          o2.style.height = (total - size1) + 'px';
          this.#barObj.style.top = (size1 - this.#barSize2) + 'px';
        }

        // event listener functions bound to the element that can be canceled
        this.#fMove = this.#handleMove.bind(this);
        this.#fCancel = this.#handleUp.bind(this);
      }
    } // constructor()

    // dragging the bar has started, establish more handlers and calculate offset
    #handleDown(evt) {
      // console.log("#handleDown()", this, this.#barObj, evt.target);

      if (evt.target == this.#barObj) {
        window.addEventListener('mousemove', this.#fMove);
        window.addEventListener('touchmove', this.#fMove);
        window.addEventListener('mouseup', this.#fCancel);
        window.addEventListener('touchup', this.#fCancel);
        if (this.#isHorizontal) {
          this.#offset = this.#panelObjs[0].offsetWidth - this.#barObj.getBoundingClientRect().left + this.#barSize2;
        } else {
          this.#offset = this.#panelObjs[0].offsetHeight - this.#barObj.getBoundingClientRect().top + this.#barSize2;
        }
      }
    }

    // dragging the bar...
    #handleMove(evt) {
      if (this.#isHorizontal) {
        const total = this.clientWidth;
        const left = this.#offset - window.scrollX + (evt.pageX || evt.changedTouches[0].pageX);

        if ((left > 0) && (left < total)) {
          // resize the 2 panels;
          this.#panelObjs[0].style.width = left + 'px';
          this.#panelObjs[1].style.width = (total - left) + 'px';
          this.#barObj.style.left = (left - this.#barSize2) + 'px';
        }

      } else {
        const total = this.clientHeight;
        const top = this.#offset - window.scrollY + (evt.pageY || evt.changedTouches[0].pageY);

        if ((top > 0) && (top < total)) {
          // resize the 2 panels;
          this.#panelObjs[0].style.height = top + 'px';
          this.#panelObjs[1].style.height = (total - top) + 'px';
          this.#barObj.style.top = (top - this.#barSize2) + 'px';
        }
      }
    }

    // dragging the bar has finished. cleanup as all sizing has been done while moving.
    #handleUp() {
      // console.log("#handleUp()");
      window.removeEventListener('mousemove', this.#fMove);
      window.removeEventListener('mouseup', this.#fCancel);
      window.removeEventListener('touchmove', this.#fMove);
      window.removeEventListener('touchmove', this.#fCancel);
    }

    // when using the mouse
    onmousedown(evt) {
      this.#handleDown(evt);
    }

    // when using a touchscreen
    ontouchstart(evt) {
      this.#handleDown(evt);
    }

  }
</script>